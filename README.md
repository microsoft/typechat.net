# TypeChat.NET

TypeChat.NET is an experimental project from the [Microsoft Semantic Kernel](https://github.com/microsoft/semantic-kernel) team. TypeChat.NET brings the ideas of [TypeChat](https://github.com/microsoft/TypeChat) to .NET. 

TypeChat.NET helps you build natural language interfaces with LLMs using strong validated types and type-safe programs. 

        // Translates user intent into strongly typed Calendar Actions
        var translator = new JsonTranslator<CalendarActions>(
            new LanguageModel(Config.LoadOpenAI())
        );

TypeChat.NET is in **active development** with frequent updates. The framework will evolve as the team explores the space and incorporates feedback. Currently supported scenarios are shown in the examples. Documentation will continue to improve. When in doubt, please look at the code.  

# Assemblies
TypeChat.NET consists of the following assemblies:
* **TypeChat**: Classes (JsonTranslator<T>) that translate user intent into strongly typed and validated objects. Additionally includes:
  * Support for automatically exporting .NET type information as schema expressed using the concise syntax of Typescript. This schema is sent to language models. 
  * Validation of returned JSON. 

* **TypeChat.Program**: Classes to synthesize, validate and run  ***JSON programs***. 

* **TypeChat.SemanticKernel**: Integration with Microsoft Semantic Kernel: Language models, Plugins and Embeddings.

* **TypeChat.Dialog** (Early): Classes for working with interactive Agents that have history. 

* **TypeChat.App**: Useful support classes and extensions used by Typechat examples, such as Text Classifiers. These may also be useful for other apps built using Typechat


## TypeChat ##
Brings TypeChat to .NET with .NET idiom introduced as appropriate.
* Json Translators
* Json Validators
* Schema Exporters from .NET Types to schema expressed using Typescript. 
Schema export includes support for:
* Dynamic export at runtime. This is needed for scenarios where the schema must include dynamic lists, such as relevant product names or lists of players in a team.
* Vocabularies: easy unions of string tables, like in Typescript, along with support for dynamic loading. See examples: CoffeeShop and CoffeeShop2.

## TypeChat.Program ##
TypeChat.Program translates natural language requests into simple programs (***Plans***), represented as JSON. These programs are then type checked, compiled and run with type safety.
TypeChat.Program includes:
- Program Translator: translates user intent into programs that follow the [Program Grammar](src/typechat.program/ProgramSchema.ts)
- Program Interpreter: Executes programs generated by ProgramTranslator using an interpreter.
- Program Compiler: uses the dynamic language runtime (DLR) to compile programs/plans into verifiable typesafe code that can be checked for errors... and ***repaired***. 
- Program C# Transpiler/Compiler (experimental): Transpile programs into C# and compile them into typesafe assemblies with Roslyn. Compilation diagnostics can be used to repair programs.  

        // Translates user intent into typed Programs that call
        // methods on a Math API
        _api = new MathAPI();
        _translator = new ProgramTranslator<IMathAPI>(
            new LanguageModel(Config.LoadOpenAI()),
            _api
        );
 
## TypeChat.SemanticKernel ##

The library contains classes for:
* LLM bindings for TypeChat using the Semantic Kernel. All TypeChat examples use the Semantic Kernel to call LLMs
* **Program synthesis with Plugins**: Automatically turns registered plugins into a PluginAPI that programs synthesized by the LLM can call. [Plugins Example](examples/Plugins/Program.cs)
 
# TypeChat.Dialog
TypeChat.Dialog is an early version of framework desiged for strongly typed interactions with Agents with built in interaction history and other features. 

    // Create an agent that interactively helps the user enter their health information, such as medications and conditions
    new Agent<HealthData>(new LanguageModel(Config.LoadOpenAI()))

# TypeChat.App
Contains classes used by Typechat examples. These classes may be generally useful for apps built on top of Typechat. Helper classes include:
* Text Classification
* Input routing to sub-apps and schemas
* Program synthesis of programs that call Plugins
* Console Apps

# Getting Started 
## Building

* Visual Studio 2022. 
  * Load **typechat.sln** from the root directory. 
  * Restore packages
  * Build

* Command Line
  * Launch a command prompt
  * Go to the root directory of the project
  * dotnet Typechat.sln
 

## Nuget Packages

## Examples

To see TypeChat in action, explore the [TypeChat example projects](./examples). 

* Learn about Typechat, JsonTranslator and schemas from these examples: 
  * Sentiment: the simplest example that demonstrates JsonTranslator and other core features 
  * CoffeeShop
  * Calendar
  * Restaurant
  * MultiSchema
* Learn about TypeChat.Program and program synthesis from these examples:
  * Math
  * Plugins (program synthesis that target Semantic Kernel Plugins)

### Api Key
To run the examples, you will need an **API key** for an Open AI service. Both Azure Open AI and the Open AI service are supported. 
- Go to the ***examples*** folder in the solution
- Make a copy of the appSettings.json file. Name it **appSettings.Development.json**. This file contains a local override of the settings in appSettings.json
- Add your Api Key to **appSettings.Development.json**. 

### Inputs
- Each example includes an **input.txt** with sample input. 
- Pass the input file as an argument to run the example in **batch mode**. 

# License

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or
contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

# Trademarks

This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft 
trademarks or logos is subject to and must follow 
[Microsoft's Trademark & Brand Guidelines](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general).
Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship.
Any use of third-party trademarks or logos are subject to those third-party's policies.
