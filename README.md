# TypeChat.NET

TypeChat.NET is an **experimental project** from the [Microsoft Semantic Kernel](https://github.com/microsoft/semantic-kernel) team. TypeChat.NET brings the ideas of [TypeChat](https://github.com/microsoft/TypeChat) to .NET. 

TypeChat.NET helps you build natural language interfaces with language models using strong types, type validation and type safe programs (plans). Strong typing may help make software that uses language models more deterministic and reliable.    

        // Translates user intent into strongly typed Calendar Actions
        var translator = new JsonTranslator<CalendarActions>(
            new LanguageModel(Config.LoadOpenAI())
        );

TypeChat.NET is in **active development** with frequent updates. The framework and programming model will evolve as the team explores the space and incorporates feedback. Supported scenarios are shown in the examples. Documentation will also continue to improve. When in doubt, please look at the code.  

# Assemblies
TypeChat.NET consists of the following assemblies:

* **TypeChat**: Classes that translate user intent into strongly typed and validated objects. 

* **TypeChat.Program**: Classes to synthesize, validate and run  ***JSON programs***. 

* **TypeChat.SemanticKernel**: Integration with Microsoft Semantic Kernel for Language models, Plugins and Embeddings.

* **TypeChat.Dialog**: Classes for working with interactive Agents that have history. 

* **TypeChat.App**: Support classes and extensions used by Typechat examples. These classes may be useful for other apps built using Typechat.


## TypeChat ##
TypeChat uses language models to translate user intent into JSON that adheres to a schema. This JSON is then validated and deserialized into a typed object, with additional constraint checking applied as needed.

TypeChat includes:
* Json Translators (JsonTranslator<T>)
* Json Validators
* Schema Exporters. Generate schema for .NET Types using the concise syntax of Typescript. Includes support for:
  * Dynamic export at runtime. This is especially needed for scenarios where the schema must include dynamic lists and vocabularies: e.g. available product names, lists of players in a team.
  * Vocabularies: easy unions of string tables, like in Typescript, along with support for dynamic loading. 
  * Auomated schema export supports common scenarios, as shown in the examples. Additional scenarios may be supported in the future. 
* Extensibility interfaces let you use custom hand (such as hand-authored written) schemas, validators and even prompts.
* Classifiers used to route requests to child or hierarchical schemas and handlers


## TypeChat.Program ##
TypeChat.Program translates natural language requests into simple programs (***Plans***), represented as JSON. 

JSON programs can be thought of as a [DSL](https://en.wikipedia.org/wiki/Domain-specific_language) or [Plan](https://learn.microsoft.com/en-us/semantic-kernel/ai-orchestration/planners/?tabs=Csharp), expressed in JSON, with an associated [**grammar**](src/typechat.program/ProgramSchema.ts) that is enforced. JSON programs can be type checked against the APIs they target. They can be then be run using interpreter, or compiled into .NET code. Both mechanisms can enforce type safety.

TypeChat.Program includes:
* Program Translator: translates user intent into programs that follow the [Program Grammar](src/typechat.program/ProgramSchema.ts)
* Program Interpreter: runs programs generated by ProgramTranslator using an interpreter.
* Program Compiler: demonstrates how to use the dynamic language runtime (DLR) to compile programs/plans into verifiable typesafe code that can be checked for errors... and ***repaired***. 
* Program C# Transpiler/Compiler (experimental): demonsrates how to transpile programs into C# and compile them with Roslyn. The compiler does type checking and compilation diagnostics can be used to repair programs.  

        // Translates user intent into typed Programs that call
        // methods on a Math API
        _api = new MathAPI();
        _translator = new ProgramTranslator<IMathAPI>(
            new LanguageModel(Config.LoadOpenAI()),
            _api
        );
 
## TypeChat.SemanticKernel ##
TypeChat.SemanticKernel provides bindings for Language Models, Plugins and Embeddings for components in Typechat.NET.

TypeChat.SemanticKernel includes classes that demonstrate:
* **Json Programs for Plugins**: turns registered plugins into a Plugin **API** and then generate Json programs that call these APIs. [Plugins Example](examples/Plugins/Program.cs)
* Language model and embeddings access. All TypeChat examples use the Semantic Kernel to call models and generate embeddings. 
 
## TypeChat.Dialog
(Early)
TypeChat.Dialog demonstrates how TypeChat.NET may be used for strongly typed interactions with message passing Agents or Bots. These agents can include features such as built in interaction history. 

TypeChat.Dialog includes support for:
* Agents, Agents with History
* Messages, Message Streams

      // Create an agent with history
      _agent = new AgentWithHistory<HealthDataResponse>(new LanguageModel(Config.LoadOpenAI()));

## TypeChat.App
A utility library with classes used by Typechat examples. These classes may be generally useful for apps built on top of Typechat. Helper classes include:
* Program synthesis of programs that call Plugins
* Console Apps

# Getting Started 
## Building

* Visual Studio 2022. 
  * Load **typechat.sln** from the root directory. 
  * Restore packages
  * Build

* Command Line
  * Launch a command prompt
  * Go to the root directory of the project
  * dotnet build Typechat.sln

## Nuget Packages

## Examples

To see TypeChat in action, explore the [TypeChat example projects](./examples). The list below describes which examples will best introduc which concept

* Typechat, JsonTranslator and Schemas: 
  * Sentiment: the simplest example that demonstrates JsonTranslator and other core features 
  * CoffeeShop: Natural language ordering at a coffee shop
  * Calendar: Transform language into calendar actions
  * Restaurant: Order at a pizza restaurant

* Hierarchical schemas and routing:
  * MultiSchema: dynamically route user intent to other 'sub-apps'
  * SchemaHierarchy: A Json Translator than uses multiple child JsonTranslators

* TypeChat.Program and program synthesis from these examples:
  * Math: Turn user requests into calculator programs
  * Plugins (program synthesis that target Semantic Kernel Plugins)

* Typed conversations with Agents:
  * Healthdata
  
### Api Key
To run the examples, you will need an **API key** for an Open AI service. Both Azure Open AI and the Open AI service are supported. 
- Go to the ***examples*** folder in the solution
- Make a copy of the appSettings.json file. Name it **appSettings.Development.json**. This file contains a local override of the settings in appSettings.json
- Add your Api Key to **appSettings.Development.json**. 

### Inputs
- Each example includes an **input.txt** with sample input. 
- Pass the input file as an argument to run the example in **batch mode**. 

# License

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or
contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

# Trademarks

This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft 
trademarks or logos is subject to and must follow 
[Microsoft's Trademark & Brand Guidelines](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general).
Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship.
Any use of third-party trademarks or logos are subject to those third-party's policies.
